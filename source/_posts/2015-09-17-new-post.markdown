---
layout: post
title: "iOS中的几种本地数据存储方法"
date: 2015-09-17 00:38:12 +0800
comments: true
categories: 
---
这是一篇关于数据存储的知识总结。仅涉及到本地数据的存取，适合iOS开发的初学者。


应用沙盒
---
>每个iOS应用都有自己的应用沙盒(就是应用文件系统目录)，与其他应用的沙盒隔离。每个应用只能待在自己的沙盒里，其他应用不能访问该沙盒。

#####沙盒由以下几个文件组成：
- layer（应用程序包）:包含了所有的资源文件和可执行文件
- Documents：保存应用运行时生成的需要持久化的数据，iTunes同步设备是会备份该目录。例如，游戏应用可将游戏存档板存在该目录
- temp：保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录
- Library/Caches：保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大、不需要备份的非重要数据
- Library/Preference：保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录
<!--more-->
#####获取沙盒目录的方法：
- 利用`NSHomeDirectory函数`：不建议使用，因为新版本的操作系统可能会修改目录名

```
NSString *home = NSHomeDirectory();
```

- 利用`NSSearchPathForDirectoriesInDomains`函数

```
NSArray *array =  NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde);
```
| 参数 | 说明 |
| -- | -- |
| directory | 枚举类型，选择要查找的文件 |
| domainMask | 枚举类型，查找的范围 |
| expandTilde | 是否展开全路径 |

示例：表示在当前用户下（NSUserDomainMask）去搜索caches文件（NSCachesDirectory），并且展开全路径。最后得到的数组的[0]位置就是caches文件的全路径
```
//获取Caches文件夹的路径
NSString *cachesPath =  NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];
```
- 利用`NSTemporaryDirectory`函数直接得到temp的文件路径

```
NSString *tmp = NSTemporaryDirectory();
```

属性列表（plist）
---
>属性列表是一种XML格式的文件，拓展名为plist
。如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，就可以使用writeToFile:atomically:方法直接将对象写到属性列表文件中。但是plist不能存储自定义对象。

#####写入：

```
//获取Caches文件夹的路径
NSString *cachesPath =  NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];

// 拼接文件路径
NSString *filePath = [cachesPath stringByAppendingPathComponent:@"user.plist"];

// File文件全路 径
[users writeToFile:filePath atomically:YES];
```

#####读取：

```
// plist读取：之前是对象怎么存的，读取出来也是什么数组
NSString *cachesPath =  NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];

// 拼接文件路径
NSString *filePath = [cachesPath stringByAppendingPathComponent:@"user.plist"];
NSArray *arr = [NSArray arrayWithContentsOfFile:filePath];
```

偏好设置
---
>很多iOS应用都支持偏好设置，比如保存用户名、密码、字体大小等设置，iOS提供了一套标准的解决方案来为应用加入偏好设置功能。每个应用都有个`NSUserDefaults`实例，通过它来存取偏好设置
。

#####存储：

```
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
[defaults setObject:@"jsjy" forKey:@"username"];
[defaults setFloat:18.0f forKey:@"text_size"];
[defaults setBool:YES forKey:@"auto_login"];
```

#####读取：

```
// 以什么样的方式存储，就以什么样的方式读取
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
NSString *username = [defaults stringForKey:@"username"];
float textSize = [defaults floatForKey:@"text_size"];
BOOL autoLogin = [defaults boolForKey:@"auto_login"];
```

注意：NSUserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用`[default synchornize]`方法强制写入

#####偏好设置的优点：
- 不需要关心文件名，系统会自动帮你生成一个文件名
- 可以快速做键值对的存储


NSKeyedArchiver
---
>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用`NSKeyedArchiver`进行归档和恢复
，自定义的对象也可以用`NSKeyedArchiver`进行归档和恢复。

#####不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以。NSCoding协议有两个方法：

- encodeWithCoder:方法

每次归档对象时，都会调用这个方法。一般在这个方法里面指定如何归档对象中的每个实例变量，可以使用`encodeObject: forKey:`方法归档实例变量

- initWithCoder:

每次从文件中恢复(解码)对象时，都会调用这个方法。一般在这个方法里面指定如何解码文件中的数据为对象的实例变量，可以使用`decodeObject: forKey`方法解码实例变量

#####两个示例：

- 归档和解档NSArray数据

```
// 归档
NSArray *array = [NSArray arrayWithObjects:@”a”,@”b”,nil];
[NSKeyedArchiver archiveRootObject:array toFile:filePath];

// 解档
NSArray *array = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];
```

- 归档和解档自定义对象

```
// 遵守协议
@interface Person : NSObject<NSCoding>
@property (nonatomic, copy) NSString *name;
@property (nonatomic, assign) int age;
@property (nonatomic, assign) float height;
@end

@implementation Person
// 实现协议方法
- (void)encodeWithCoder:(NSCoder *)encoder {
    [encoder encodeObject:self.name forKey:@"name"];
    [encoder encodeInt:self.age forKey:@"age"];
    [encoder encodeFloat:self.height forKey:@"height"];
}
- (id)initWithCoder:(NSCoder *)decoder {
    if (self = [super init]) {
      self.name = [decoder decodeObjectForKey:@"name"];
      self.age = [decoder decodeIntForKey:@"age"];
      self.height = [decoder decodeFloatForKey:@"height"];
    }
    return self;
}
@end
```
注意：如果父类也遵守了NSCoding协议，那在实现`initWithCode:`方法时应该`[super initWithCode:decoder]`做父类的初始化操作，确保继承的实例变量也能被解码，即也能被恢复
。而在`encodeWithCoder:`方法中也应该`[super encodeWithCoder:encoder]`确保继承的实例变量也能被编码，即也能被归档
。

```
// 归档
Person *person = [[Person alloc] init];
person.name = @"JSJY";
person.age = 27;
person.height = 1.0f;
[NSKeyedArchiver archiveRootObject:person toFile:filePath];

// 解档
Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];

```
